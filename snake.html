<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<title>Real Snake ‚Äî Ë¥™ÂêÉËõá</title>
<style>
  :root{
    --bg:#0b0c19; --card:#0f1026; --ring:#ffffff1a;
    --ink:#eaf2ff; --mut:#9fb0d9; --acc:#ffd86a;
    --g1:#71e1ff; --g2:#25c3ff; --g3:#c06bff;
    --snake:#74ffb4; --head:#d9ff7a; --food:#ff6ec4; --wall:#ffc857;
  }
  *{box-sizing:border-box; user-select:none}
  html,body{height:100%}
  body{
    margin:0; background:
      radial-gradient(1200px 800px at 50% -10%, #242a60aa 0%, transparent 70%),
      linear-gradient(180deg,#0b0c19,#060712);
    color:var(--ink); font:15px/1.5 Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;
    display:grid; place-items:center;
  }
  .wrap{position:relative}
  canvas{
    width:min(92vw,560px); height:min(92vw,560px);
    max-width:560px; max-height:560px;
    background:linear-gradient(180deg,#0e0f22,#070813);
    border:1px solid var(--ring); border-radius:14px;
    box-shadow:0 20px 60px #0006, inset 0 0 50px #0008;
  }
  .hud{
    position:absolute; inset:auto 0 100% 0; display:flex; gap:14px; align-items:center; justify-content:space-between;
    padding:10px 4px 16px; max-width:560px; margin:0 auto; width:min(92vw,560px);
  }
  .badge{
    padding:8px 12px; border-radius:12px; background:#121331; border:1px solid var(--ring);
    box-shadow:inset 0 0 24px #0006;
  }
  .btn{
    padding:10px 16px; border-radius:999px; border:0; cursor:pointer; color:#080a14; font-weight:700;
    background:linear-gradient(90deg,#ff6ec4,#7873f5);
    box-shadow:0 8px 24px #6c5ce733;
  }
  .btn.secondary{background:linear-gradient(90deg,#71e1ff,#25c3ff); color:#06121a}
  .overlay{
    position:absolute; inset:0; display:flex; flex-direction:column; align-items:center; justify-content:center;
    background:#0008; backdrop-filter:blur(4px);
    text-align:center; padding:24px;
    border-radius:14px;
  }
  h1{
    margin:0 0 10px; font-size:34px;
    background:linear-gradient(90deg,#ff6ec4,#7873f5);
    -webkit-background-clip:text; -webkit-text-fill-color:transparent;
  }
  .hint{color:var(--mut)}
  .toggles{display:flex; gap:8px; flex-wrap:wrap; justify-content:center; margin-top:14px}
  label.switch{
    display:flex; align-items:center; gap:8px; background:#10122c; border:1px solid var(--ring); padding:8px 12px; border-radius:999px;
  }
  .mobile-ctrl{
    position:absolute; inset:auto 0 0 0; display:flex; justify-content:center; pointer-events:none;
  }
  .swipe-pad{
    width:220px; height:220px; border-radius:50%;
    background:#0d0f23cc; border:1px dashed #ffffff22; margin:16px 0;
    pointer-events:auto; touch-action:none;
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="badge">Score: <b id="score">0</b></div>
      <div class="badge">Speed: <b id="speed">1.00x</b></div>
      <div class="badge">Length: <b id="len">0</b></div>
      <button id="pauseBtn" class="btn secondary">Pause</button>
    </div>

    <canvas id="c" width="560" height="560"></canvas>

    <div id="overlay" class="overlay">
      <h1>üêç Real Snake</h1>
      <p class="hint">WASD / Arrow keys to steer. Swipe on mobile.</p>
      <div class="toggles">
        <label class="switch">
          <input id="wallsToggle" type="checkbox" checked>
          <span>Walls ON</span>
        </label>
        <label class="switch">
          <input id="wrapToggle" type="checkbox">
          <span>Wrap at edges</span>
        </label>
      </div>
      <div style="display:flex; gap:10px; margin-top:16px">
        <button id="startBtn" class="btn">START</button>
        <button id="howBtn" class="btn secondary">HOW TO PLAY</button>
      </div>
    </div>

    <div class="mobile-ctrl">
      <div id="pad" class="swipe-pad" aria-label="Swipe to steer"></div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // ----- CONFIG -----
  const W = canvas.width, H = canvas.height;
  const GRID = 20;               // for subtle guide + spawn snapping
  const BASE_SPEED = 120;        // px/sec starting speed
  const MAX_SPEED = 280;         // cap
  const SPEED_PER_FOOD = 8;      // add speed per eat
  const SEGMENT_SPACING = 10;    // px between snake samples
  const HEAD_RADIUS = 7;
  const BODY_RADIUS = 6;
  const PATH_MAX = 4000;         // max path length history
  const WALL_COUNT = 14;         // random blocks
  const FOOD_RADIUS = 6;

  // ----- STATE -----
  let playing = false, paused = false, lastT = 0;
  let score = 0, speed = BASE_SPEED, growth = 0, targetAngle = 0, angle = 0;
  let wrapEdges = false, wallsOn = true;

  // Path-based snake: head moves continuously; body samples along the path.
  /** @type {{x:number,y:number}[]} */
  let path = [];         // deque of points (newest at front)
  let lengthDesired = 140; // initial length
  let food = null;
  let walls = [];

  // ----- UI ELs -----
  const scoreEl = document.getElementById('score');
  const lenEl   = document.getElementById('len');
  const spdEl   = document.getElementById('speed');
  const overlay = document.getElementById('overlay');
  const startBtn= document.getElementById('startBtn');
  const howBtn  = document.getElementById('howBtn');
  const pauseBtn= document.getElementById('pauseBtn');
  const pad     = document.getElementById('pad');
  const wallsToggle = document.getElementById('wallsToggle');
  const wrapToggle  = document.getElementById('wrapToggle');

  wallsToggle.addEventListener('change', () => { wallsOn = wallsToggle.checked; drawStatic(); });
  wrapToggle.addEventListener('change', () => { wrapEdges = wrapToggle.checked; });

  // ----- HELPERS -----
  const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
  function dist(a,b){const dx=a.x-b.x, dy=a.y-b.y; return Math.hypot(dx,dy);}
  function point(x,y){return {x,y};}

  function randomCell() {
    // Snap to grid center-ish to look nice
    const gx = Math.floor(Math.random()*(W/GRID-2))+1;
    const gy = Math.floor(Math.random()*(H/GRID-2))+1;
    return point(gx*GRID + GRID/2, gy*GRID + GRID/2);
  }

  function spawnFood(){
    let p;
    do { p = randomCell(); } while (walls.some(w => p.x>w.x-10 && p.x<w.x+w.w+10 && p.y>w.y-10 && p.y<w.y+w.h+10));
    food = p;
  }

  function spawnWalls(){
    walls = [];
    for (let i=0;i<WALL_COUNT;i++){
      const w = (Math.random()<0.5? GRID*2: GRID*3);
      const h = (Math.random()<0.5? GRID*2: GRID*3);
      const x = Math.floor(Math.random()*((W-w)/GRID))*GRID + 0.5;
      const y = Math.floor(Math.random()*((H-h)/GRID))*GRID + 0.5;
      walls.push({x,y,w,h});
    }
  }

  function init(){
    score = 0;
    speed = BASE_SPEED;
    growth = 0;
    lengthDesired = 160;
    targetAngle = angle = 0;
    path = [];
    const start = point(W*0.5, H*0.6);
    path.unshift({...start});
    spawnFood();
    spawnWalls();
    updateHUD();
    drawStatic();
  }

  function updateHUD(){
    scoreEl.textContent = score;
    lenEl.textContent = Math.round(lengthDesired);
    spdEl.textContent = (speed/BASE_SPEED).toFixed(2)+'x';
  }

  // ----- INPUT (keyboard) -----
  window.addEventListener('keydown', (e)=>{
    if(!playing) return;
    const k = e.key.toLowerCase();
    if (k==='arrowleft'||k==='a')  targetAngle -= Math.PI/2;
    if (k==='arrowright'||k==='d') targetAngle += Math.PI/2;
    if (k==='arrowup'||k==='w')    targetAngle = targetAngle; // noop, keep heading
    if (k==='arrowdown'||k==='s')  targetAngle += Math.PI;    // flip
  });

  // ----- INPUT (swipe) -----
  (()=> {
    let dragging=false, sx=0, sy=0;
    const TH=18; // threshold
    function onStart(x,y){ dragging=true; sx=x; sy=y; }
    function onMove(x,y){
      if(!dragging) return;
      const dx=x-sx, dy=y-sy;
      if (Math.hypot(dx,dy) > 32){
        if (Math.abs(dx)>Math.abs(dy)) targetAngle += (dx>0? +Math.PI/2 : -Math.PI/2);
        else                           targetAngle += (dy>0? +Math.PI/2 : -Math.PI/2);
        dragging=false;
      }
    }
    function onEnd(){ dragging=false; }
    pad.addEventListener('pointerdown',e=>{pad.setPointerCapture(e.pointerId); onStart(e.clientX,e.clientY);});
    pad.addEventListener('pointermove', e=>onMove(e.clientX,e.clientY));
    pad.addEventListener('pointerup',   onEnd);
    pad.addEventListener('pointercancel',onEnd);
  })();

  // ----- DRAW STATIC (grid & walls) -----
  function drawStatic(){
    ctx.clearRect(0,0,W,H);
    // grid
    ctx.strokeStyle = 'rgba(255,255,255,0.05)';
    ctx.lineWidth = 1;
    for(let x=0;x<=W;x+=GRID){ ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,H); ctx.stroke(); }
    for(let y=0;y<=H;y+=GRID){ ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(W,y); ctx.stroke(); }

    if(wallsOn){
      for(const w of walls){
        ctx.fillStyle = 'rgba(255,200,87,0.12)';
        ctx.strokeStyle = '#ffc85766';
        ctx.lineWidth = 2;
        roundRect(ctx,w.x,w.y,w.w,w.h,8,true,true);
      }
    }
  }

  // Rounded rect helper
  function roundRect(ctx,x,y,w,h,r, fill, stroke){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr,y);
    ctx.arcTo(x+w,y,x+w,y+h,rr);
    ctx.arcTo(x+w,y+h,x,y+h,rr);
    ctx.arcTo(x,y+h,x,y,rr);
    ctx.arcTo(x,y,x+w,y,rr);
    if (fill) ctx.fill();
    if (stroke) ctx.stroke();
  }

  // ----- RENDER SNAKE (curved body sampled along path) -----
  function render(foodPulse){
    drawStatic();

    // Food
    if (food){
      const pul = 0.6 + 0.4*Math.sin(foodPulse*4);
      ctx.shadowColor = '#ff6ec4';
      ctx.shadowBlur = 18*pul;
      ctx.fillStyle = '#ff6ec4';
      ctx.beginPath(); ctx.arc(food.x, food.y, FOOD_RADIUS, 0, Math.PI*2); ctx.fill();
      ctx.shadowBlur = 0;
    }

    // Build sample points along the path according to desired body length.
    const samples = [];
    let acc = 0, idx = 0;
    samples.push(path[0]);
    while (idx < path.length-1 && acc < lengthDesired){
      const a = path[idx], b = path[idx+1];
      const segLen = dist(a,b);
      if (acc + segLen > SEGMENT_SPACING * (samples.length)){
        // interpolate at needed distance
        const need = SEGMENT_SPACING * (samples.length) - acc;
        const t = clamp(need / segLen, 0, 1);
        samples.push({ x: a.x + (b.x-a.x)*t, y: a.y + (b.y-a.y)*t });
      }else{
        idx++;
        acc += segLen;
      }
    }

    // Draw body circles tapering slightly
    for (let i=samples.length-1;i>=1;i--){
      const t = i/(samples.length-1);
      const r = BODY_RADIUS * (0.85 + 0.15*Math.sin(t*Math.PI));
      const g = Math.floor(190 + 50*(1-t));
      ctx.fillStyle = `rgba(116,255,180,${0.25+0.75*(1-t)})`;
      ctx.beginPath(); ctx.arc(samples[i].x, samples[i].y, r+2, 0, Math.PI*2); ctx.fill();

      // main body
      ctx.fillStyle = '#74ffb4';
      ctx.beginPath(); ctx.arc(samples[i].x, samples[i].y, r, 0, Math.PI*2); ctx.fill();
    }

    // Head (brighter)
    const h = samples[0];
    ctx.shadowColor = '#d9ff7a'; ctx.shadowBlur = 22;
    ctx.fillStyle = '#d9ff7a';
    ctx.beginPath(); ctx.arc(h.x, h.y, HEAD_RADIUS, 0, Math.PI*2); ctx.fill();
    ctx.shadowBlur = 0;

    // Head eyes (tiny)
    const eyeOff = 4;
    const ex = Math.cos(angle) * eyeOff, ey = Math.sin(angle) * eyeOff;
    ctx.fillStyle = '#0b0c19';
    ctx.beginPath(); ctx.arc(h.x + ex - ey*0.4, h.y + ey + ex*0.4, 1.6, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(h.x + ex + ey*0.4, h.y + ey - ex*0.4, 1.6, 0, Math.PI*2); ctx.fill();
  }

  // ----- GAME LOOP -----
  function tick(ts){
    if (!playing || paused){ lastT = ts; requestAnimationFrame(tick); return; }
    if (!lastT) lastT = ts;
    const dt = (ts - lastT) / 1000;
    lastT = ts;

    // Smooth steer toward targetAngle
    const diff = ((targetAngle - angle + Math.PI*3) % (Math.PI*2)) - Math.PI;
    angle += clamp(diff, -4*dt, 4*dt); // limit turn speed for nice curve

    // Move head forward
    const head = {...path[0]};
    head.x += Math.cos(angle) * speed * dt;
    head.y += Math.sin(angle) * speed * dt;

    // Wrap/Collide edges
    if (wrapEdges){
      if (head.x<0) head.x+=W; if (head.x>W) head.x-=W;
      if (head.y<0) head.y+=H; if (head.y>H) head.y-=H;
    }else{
      if (head.x<0||head.x>W||head.y<0||head.y>H) return gameOver();
    }

    // Collide with walls
    if (wallsOn){
      for(const w of walls){
        if (head.x>w.x && head.x<w.x+w.w && head.y>w.y && head.y<w.y+w.h){
          return gameOver();
        }
      }
    }

    // Add head to path
    path.unshift(head);

    // Trim path to desired length + slack
    let total = 0, i=0;
    while (i < path.length-1){
      const d = dist(path[i], path[i+1]);
      total += d;
      if (total > PATH_MAX) { path.pop(); } // hard cap
      i++;
      if (total > lengthDesired + 60) break;
    }
    while (path.length > i+2) path.pop();

    // Self collision: check head against body samples (skip near-head)
    for (let j=8; j<path.length; j+=4){
      if (dist(head, path[j]) < BODY_RADIUS+2) return gameOver();
    }

    // Eat food
    if (food && dist(head, food) < HEAD_RADIUS + FOOD_RADIUS){
      score++;
      growth += 28;                 // add length
      lengthDesired += growth;
      growth = 0;
      speed = clamp(speed + SPEED_PER_FOOD, BASE_SPEED, MAX_SPEED);
      spawnFood();
      updateHUD();
    }

    render(ts/1000);
    requestAnimationFrame(tick);
  }

  // ----- CONTROL -----
  function start(){
    playing = true; paused = false; lastT = 0;
    overlay.style.display='none';
    init();
    requestAnimationFrame(tick);
  }
  function pauseToggle(){
    if (!playing) return;
    paused = !paused;
    pauseBtn.textContent = paused ? 'Resume' : 'Pause';
  }
  function gameOver(){
    playing = false;
    overlay.style.display='flex';
    overlay.innerHTML = `
      <h1>Game Over</h1>
      <p class="hint">Score: <b>${score}</b> ¬∑ Max Speed: <b>${(speed/BASE_SPEED).toFixed(2)}x</b></p>
      <div class="toggles" style="margin-top:8px">
        <label class="switch">
          <input id="wallsToggle2" type="checkbox" ${wallsOn?'checked':''}>
          <span>Walls ON</span>
        </label>
        <label class="switch">
          <input id="wrapToggle2" type="checkbox" ${wrapEdges?'checked':''}>
          <span>Wrap at edges</span>
        </label>
      </div>
      <div style="display:flex; gap:10px; margin-top:16px">
        <button id="restartBtn" class="btn">PLAY AGAIN</button>
        <button id="howBtn2" class="btn secondary">HOW TO PLAY</button>
      </div>
    `;
    // rebind toggles
    overlay.querySelector('#restartBtn').onclick = start;
    overlay.querySelector('#howBtn2').onclick = showHow;
    overlay.querySelector('#wallsToggle2').onchange = (e)=>{wallsOn=e.target.checked;};
    overlay.querySelector('#wrapToggle2').onchange  = (e)=>{wrapEdges=e.target.checked;};
  }
  function showHow(){
    overlay.innerHTML = `
      <h1>How to Play</h1>
      <p class="hint" style="max-width:520px">
        Steer with <b>Arrow keys / WASD</b> or <b>swipe</b> on the round pad.<br/>
        Eat the glowing orb to grow and speed up. Avoid walls (toggleable) and your own body.<br/>
        <br/>
        <b>Tips:</b> Smooth turns have a slight turning radius‚Äîplan ahead like classic snake.
      </p>
      <div style="display:flex; gap:10px; margin-top:16px">
        <button id="startBtn2" class="btn">START</button>
        <button id="backBtn" class="btn secondary">Back</button>
      </div>`;
    overlay.querySelector('#startBtn2').onclick = start;
    overlay.querySelector('#backBtn').onclick = () => {
      overlay.innerHTML = '';
      overlay.style.display='none';
      start();
    };
  }

  // Buttons
  startBtn.onclick = start;
  howBtn.onclick = showHow;
  pauseBtn.onclick = pauseToggle;

  // First paint
  init(); render(0);
})();
</script>
</body>
</html>
