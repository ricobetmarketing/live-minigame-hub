<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
<meta name="color-scheme" content="dark"/>
<title>Neon Pac Maze</title>
<style>
  :root{
    --bg:#070711;
    --maze1:#2e2b7b;      /* outer glow color */
    --maze2:#5b57f7;      /* inner stroke color */
    --dot:#f7f3ff;
    --pac:#ffd54d;
    --ghost-red:#ff4d4d;
    --ghost-pink:#ff93d2;
    --ghost-cyan:#61e7ff;
    --ghost-orange:#ffa84d;
    --fright:#4dc3ff;
    --ui:#eaf2ff;
    --ring:#ffffff19;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0;background:radial-gradient(1100px 700px at 50% -10%, #15163c 0%, transparent 60%),linear-gradient(180deg,#0b0c1a,#070711);
    color:var(--ui);font:15px/1.45 Inter,system-ui,Segoe UI,Roboto,Arial,sans-serif;touch-action:none;
    display:grid;place-items:center;gap:14px;padding:10px;
  }
  .wrap{display:flex;flex-direction:column;align-items:center;gap:8px}
  canvas{width:min(92vw,520px);height:auto;image-rendering:pixelated;border-radius:14px;box-shadow:
      0 0 0 3px var(--ring) inset, 0 10px 30px rgba(0,0,0,.5);}
  .hud{width:min(92vw,520px);display:flex;justify-content:space-between;align-items:center}
  .score{font-weight:700;letter-spacing:.5px}
  .btns{display:flex;gap:8px;align-items:center}
  .btn{
    background:linear-gradient(180deg,#1a1b3f,#0f1030);
    border:1px solid var(--ring);color:var(--ui);padding:6px 10px;
    border-radius:10px;font-weight:600;cursor:pointer;user-select:none;
    box-shadow:0 4px 14px rgba(0,0,0,.35);
  }
  .btn:active{transform:translateY(1px)}
  /* Mobile controls */
  .pad{
    width:min(92vw,520px);display:grid;grid-template-columns:1fr 1fr 1fr;
    gap:10px;margin-top:6px;user-select:none;
  }
  .pad .key{
    background:linear-gradient(180deg,#16173b,#0e1030); border:1px solid var(--ring);
    border-radius:16px; aspect-ratio:1/1; display:flex;align-items:center;justify-content:center;
    box-shadow:inset 0 0 20px rgba(120,115,245,.2), 0 8px 20px rgba(0,0,0,.4);
    font-size:22px;font-weight:800;color:#cfd2ff;
  }
  .pad .key:active{transform:scale(.98)}
  .pad .ghost{grid-column:2}
  .pad .up{grid-column:2}
  .pad .left{grid-column:1}
  .pad .right{grid-column:3}
  .pad .down{grid-column:2}
  .hint{opacity:.7;font-size:12px}
  @media (min-width:760px){ .pad{display:none} }
</style>
</head>
<body>
<div class="wrap">
  <div class="hud">
    <div class="score">SCORE: <span id="score">0</span></div>
    <div class="btns">
      <button class="btn" id="restart">Restart</button>
      <span class="hint">Desktop: Arrow keys • Mobile: D-pad or swipe</span>
    </div>
  </div>
  <canvas id="game" width="448" height="576" aria-label="Pac-style maze"></canvas>
  <div class="pad" id="pad">
    <div class="key up" data-dir="up">▲</div>
    <div class="key left" data-dir="left">◀</div>
    <div class="key right" data-dir="right">▶</div>
    <div class="key down" data-dir="down">▼</div>
  </div>
</div>

<script>
/* =========================
   Tiny Pac-style Engine
   ========================= */

// ----- Audio (no files; oscillator beeps)
const Audio = (() => {
  const Ctx = window.AudioContext || window.webkitAudioContext;
  let ctx = null;
  function ensure(){ if(!ctx) ctx = new Ctx(); return ctx; }
  function beep(freq=440, dur=0.08, type='square', gain=0.03){
    const ac = ensure();
    const o = ac.createOscillator(); const g = ac.createGain();
    o.type = type; o.frequency.value = freq; g.gain.value = gain;
    o.connect(g).connect(ac.destination);
    o.start(); o.stop(ac.currentTime + dur);
  }
  return {
    chomp(){beep(680, .05, 'square', .025)},
    power(){beep(220, .12, 'sawtooth', .035)},
    eatGhost(){beep(880, .12, 'square', .045)},
    death(){beep(110, .6, 'triangle', .06)},
    tick(){beep(520, .03, 'square', .02)},
    unlock(){ensure()} // start on first user gesture
  };
})();

// ----- Canvas setup
const cvs = document.getElementById('game');
const ctx = cvs.getContext('2d');

const TILE = 16;                 // 28x36 original Pac grid -> canvas 448x576
const W = 28, H = 36;

// ----- Maze (0=path, 1=wall, 2=dot, 3=power, 9=door)
const raw =
`1111111111111111111111111111
1............11............1
1.111.11111.11.11111.111.1.1
1*111.11111.11.11111.111.1*1
1.111.11111.11.11111.111.1.1
1..........................1
1.111.11.11111111.11.111.1.1
1.111.11.11111111.11.111.1.1
1......11....11....11......1
11111.11111  11  11111.11111
00001.11           11.10000
11111.11 111--11  11.11111
..... .   1----1   . .....
11111.11  111111  11.11111
00001.11           11.10000
11111.11 11111111 11.11111
1............11............1
1.111.11111.11.11111.111.1.1
1*..1..................1..*1
1111.11.11111111.11111.11.11
1......11....11....11......1
1.1111111.11.11.11.1111111.1
1..........................1
1111111111111111111111111111`;

// Expand to full 28x36 (add top area/score space with walls)
let MAZE = Array.from({length:H}, (_, y) => Array(W).fill(1));
const rows = raw.split('\n');
const yOffset = 6; // top empty rows
for (let y=0; y<rows.length; y++){
  const r = rows[y].padEnd(W,'1');
  for (let x=0; x<W; x++){
    const c = r[x];
    if (c===' ') MAZE[y+yOffset][x] = 0;
    else if (c==='1') MAZE[y+yOffset][x] = 1;
    else if (c==='.') MAZE[y+yOffset][x] = 2;
    else if (c==='*') MAZE[y+yOffset][x] = 3;
    else if (c==='0') MAZE[y+yOffset][x] = 0;
    else if (c==='-') MAZE[y+yOffset][x] = 9; // ghost door
  }
}
// Fill top area with dots for style
for (let y=1; y<yOffset-1; y++) for (let x=1; x<W-1; x++) MAZE[y][x]= (x%2&&y%2)?2:0;

// ----- Entities
const DIRS = {left:{x:-1,y:0}, right:{x:1,y:0}, up:{x:0,y:-1}, down:{x:0,y:1}};
const startPac = { x: 12.5, y: 26, dir: 'left' };
const startGhosts = [
  {name:'blinky', color:getCSS('--ghost-red'), x:13.5, y:17,  home:{x:26,y:1}},
  {name:'pinky',  color:getCSS('--ghost-pink'), x:12.5, y:19, home:{x:1,y:1}},
  {name:'inky',   color:getCSS('--ghost-cyan'), x:13.5, y:19, home:{x:26,y:34}},
  {name:'clyde',  color:getCSS('--ghost-orange'), x:14.5, y:19, home:{x:1,y:34}}
];

let score=0, pellets=0, frightened=0, combo=0, gameOver=false;
let pac, ghosts=[];

// Count pellets
for (let y=0;y<H;y++)for(let x=0;x<W;x++) if(MAZE[y][x]==2||MAZE[y][x]==3) pellets++;

// ----- Helpers
function getCSS(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
function tileAt(x,y){ return MAZE[Math.floor(y)]?.[Math.floor(x)] ?? 1; }
function canWalk(nx,ny){
  const t = tileAt(nx,ny);
  return t!==1 && t!==9; // 9 = ghost door (blocked for Pac)
}
function wrapX(x){ if (x<-1) return W+1; if (x>W+1) return -1; return x; }

function reset(){
  score=0; frightened=0; combo=0; pellets = 0; gameOver=false;
  for (let y=0;y<H;y++)for(let x=0;x<W;x++) if(MAZE[y][x]==2||MAZE[y][x]==3) pellets++;
  pac = {...startPac, px:0, py:0, mouth:0, next:'left', speed:.09};
  ghosts = startGhosts.map(g=>({...g, dir:'left', speed:.085, mode:'chase', eaten:false}));
  document.getElementById('score').textContent=score;
}
reset();

// ----- Input (keyboard + D-pad + swipe)
let keys = {left:0,right:0,up:0,down:0};
window.addEventListener('keydown',e=>{
  const k = e.key.replace('Arrow','').toLowerCase();
  if(k in keys){ keys[k]=1; pac.next=k; e.preventDefault(); Audio.unlock(); }
});
window.addEventListener('keyup',e=>{
  const k = e.key.replace('Arrow','').toLowerCase(); if(k in keys) keys[k]=0;
});
document.getElementById('restart').onclick=()=>{Audio.unlock(); reset();};
document.querySelectorAll('.pad .key').forEach(b=>{
  b.addEventListener('pointerdown',e=>{pac.next=b.dataset.dir; Audio.unlock();});
});
// Swipe
let touchStart=null;
cvs.addEventListener('pointerdown',e=>{touchStart={x:e.clientX,y:e.clientY}; Audio.unlock();});
window.addEventListener('pointerup',e=>{
  if(!touchStart) return;
  const dx=e.clientX-touchStart.x, dy=e.clientY-touchStart.y;
  if(Math.abs(dx)>Math.abs(dy)) pac.next = dx>10?'right':'left';
  else pac.next = dy>10?'down':'up';
  touchStart=null;
});

// ----- Game loop
let last=0;
function loop(ts){
  const dt = Math.min(32, ts - last); last=ts;
  update(dt/16); draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

function update(step){
  if(gameOver) return;
  // Pac direction change if next available
  const dNext = DIRS[pac.next], dCur = DIRS[pac.dir];
  const cx = Math.round(pac.x*2)/2, cy = Math.round(pac.y*2)/2;
  if(Math.abs(pac.x-cx)<.05 && Math.abs(pac.y-cy)<.05){
    // centered in tile -> snap and try turn
    pac.x=cx; pac.y=cy;
    const nx = pac.x + dNext.x*.51, ny = pac.y + dNext.y*.51;
    if(canWalk(nx,ny)) pac.dir=pac.next;
  }
  // Move
  const d = DIRS[pac.dir];
  const aheadX = pac.x + d.x * 0.55;   // small look-ahead
  const aheadY = pac.y + d.y * 0.55;
  if (canWalk(aheadX, aheadY)) {
    pac.x = wrapX(pac.x + d.x * pac.speed);
    pac.y =            pac.y + d.y * pac.speed;
    pac.mouth = (pac.mouth + step * 0.4) % 1;
  }
  // Eat dots
  const tx = Math.round(pac.x), ty = Math.round(pac.y);
  const t = MAZE[ty]?.[tx];
  if(t===2){ MAZE[ty][tx]=0; score+=10; pellets--; document.getElementById('score').textContent=score; Audio.chomp(); }
  if(t===3){ MAZE[ty][tx]=0; score+=50; pellets--; frightened=600; combo=0; document.getElementById('score').textContent=score; Audio.power(); }

  // Ghosts
  ghosts.forEach(g=>{
    if(g.eaten){
      // return to house center
      const dx = (13.5 - g.x), dy = (18 - g.y);
      const len = Math.hypot(dx,dy)||1;
      g.x += (dx/len)*g.speed*1.3; g.y += (dy/len)*g.speed*1.3;
      if(Math.hypot(dx,dy)<.2){ g.eaten=false; g.mode='chase'; }
      return;
    }
    // choose direction at centers
    const cx = Math.round(g.x*2)/2, cy = Math.round(g.y*2)/2;
    const centered = Math.abs(g.x-cx)<.05 && Math.abs(g.y-cy)<.05;
    if(centered){
      g.x=cx; g.y=cy;
      // target (simple chase/ scatter)
      let target = frightened>0 ? {x:Math.random()*W,y:Math.random()*H}
                   : g.mode==='chase' ? {x:pac.x, y:pac.y}
                   : g.home;
      // try directions with Manhattan distance
      const opts = ['up','left','down','right'].filter(dir=>{
        const dd = DIRS[dir];
        const bx = g.x + dd.x*.51, by = g.y + dd.y*.51;
        // prevent reversing unless stuck
        if(opposite(dir,g.dir) && Math.random()<.9) return canWalk(bx,by) && tileAt(bx,by)!==9;
        return canWalk(bx,by);
      }).sort((a,b)=>dist2(nextPos(g,a),target)-dist2(nextPos(g,b),target));
      if(opts.length) g.dir = (frightened>0)? opts.reverse()[0] : opts[0];
    }
    const d = DIRS[g.dir]; let gx = g.x + d.x*g.speed*(frightened?0.6:1), gy = g.y + d.y*g.speed*(frightened?0.6:1);
    // ghosts can cross door
    if(tileAt(gx,gy)!==1){ g.x=wrapX(gx); g.y=gy; }
  });

  // Collisions
  ghosts.forEach(g=>{
    if(g.eaten) return;
    if(Math.hypot(g.x-pac.x,g.y-pac.y)<.6){
      if(frightened>0){
        g.eaten=true; combo++; score+=200*Math.pow(2,Math.min(combo-1,3)); document.getElementById('score').textContent=score; Audio.eatGhost();
      } else {
        Audio.death(); gameOver=true;
        setTimeout(()=>alert('Game Over! Score: '+score), 50);
      }
    }
  });

  if(pellets<=0){ gameOver=true; setTimeout(()=>alert('You cleared the board! Score: '+score), 50); }
  if(frightened>0) frightened-=1;
}
function opposite(a,b){ return (a==='left'&&b==='right')||(a==='right'&&b==='left')||(a==='up'&&b==='down')||(a==='down'&&b==='up'); }
function nextPos(g,dir){ const d=DIRS[dir]; return {x:g.x+d.x, y:g.y+d.y}; }
function dist2(a,b){ const dx=a.x-b.x, dy=a.y-b.y; return dx*dx+dy*dy; }

// ----- Drawing
function draw(){
  // bg
  ctx.fillStyle=getCSS('--bg'); ctx.fillRect(0,0,cvs.width,cvs.height);

  // maze neon walls + pellets
  drawMaze();

  // pac
  const r=7; const ang = Math.sin(pac.mouth*Math.PI)*.45;
  ctx.fillStyle=getCSS('--pac');
  const px=pac.x*TILE, py=pac.y*TILE;
  ctx.beginPath();
  const base = {right:0,left:Math.PI,up:-Math.PI/2,down:Math.PI/2}[pac.dir];
  ctx.moveTo(px,py);
  ctx.arc(px,py,r, base+ang, base-ang,false);
  ctx.closePath(); ctx.fill();

  // ghosts
  ghosts.forEach(g=>{
    const gx=g.x*TILE, gy=g.y*TILE;
    const col = (frightened>0 && !g.eaten) ? getCSS('--fright') : g.color;
    drawGhost(gx,gy, col);
  });
}

function drawMaze(){
  const inner = getCSS('--maze2'), outer=getCSS('--maze1');
  // Walls
  for (let y=0;y<H;y++) for (let x=0;x<W;x++){
    if(MAZE[y][x]===1||MAZE[y][x]===9){
      const xx=x*TILE, yy=y*TILE;
      ctx.fillStyle='transparent';
      // simple neon cell edges
      ctx.strokeStyle=outer; ctx.lineWidth=6; ctx.strokeRect(xx+4,yy+4,TILE-8,TILE-8);
      ctx.strokeStyle=inner; ctx.lineWidth=2; ctx.strokeRect(xx+4,yy+4,TILE-8,TILE-8);
    }
    if(MAZE[y][x]===2){
      ctx.fillStyle=getCSS('--dot');
      ctx.beginPath(); ctx.arc(x*TILE, y*TILE, 2, 0, Math.PI*2); ctx.fill();
    }
    if(MAZE[y][x]===3){
      ctx.fillStyle=getCSS('--dot');
      ctx.beginPath(); ctx.arc(x*TILE, y*TILE, 4.2, 0, Math.PI*2); ctx.fill();
    }
  }
}

function drawGhost(x,y,color){
  const r=7, w=r*2, h=r*2;
  ctx.fillStyle=color;
  ctx.beginPath();
  ctx.moveTo(x-r, y);
  ctx.arc(x, y, r, Math.PI, 0, false);
  ctx.lineTo(x+r, y+r);
  // feet
  for(let i=3;i>=-3;i-=2){
    ctx.quadraticCurveTo(x+(i/3)*r, y+r+3, x+((i-1)/3)*r, y+r);
  }
  ctx.closePath(); ctx.fill();
  // eyes
  ctx.fillStyle='#fff'; ctx.beginPath(); ctx.arc(x-3,y-2,2,0,Math.PI*2); ctx.arc(x+3,y-2,2,0,Math.PI*2); ctx.fill();
  ctx.fillStyle='#2955ff'; ctx.beginPath(); ctx.arc(x-3+eyeDX(),y-2+eyeDY(),1.2,0,Math.PI*2); ctx.arc(x+3+eyeDX(),y-2+eyeDY(),1.2,0,Math.PI*2); ctx.fill();
}
function eyeDX(){ return 0; } function eyeDY(){ return 0; }

// ----- Init positions
(function place(){
  pac.x=startPac.x; pac.y=startPac.y;
  ghosts.forEach((g,i)=>{g.x=startGhosts[i].x; g.y=startGhosts[i].y;});
})();

</script>
</body>
</html>
